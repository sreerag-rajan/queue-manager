<!-- 4401d435-0a0f-407a-859b-176888dd8e5d b9eb9bd4-b4a1-447d-8703-a8a08e848309 -->
# Queue Manager – Phased Implementation Plan (with Unit Tests per Task)

## Folder and Task Structure

Create a planning directory with phase folders and task files:

- `@plan/phase-1/task-1.md` – Scaffold Go/Gin app with env-driven host/port + `.env.example` + unit tests
- `@plan/phase-1/task-2.md` – Add Dockerfile and .dockerignore + build/smoke tests
- `@plan/phase-1/task-3.md` – Add docker-compose with env file support + smoke tests

- `@plan/phase-2/task-1.md` – Postgres service in compose + DB connect on startup + unit/integration tests
- `@plan/phase-2/task-2.md` – RabbitMQ service in compose + provider interface + connect on startup + unit/integration tests

- `@plan/phase-3/task-1.md` – Complete RabbitMQ provider methods (declare/publish/consume/etc.) + unit/integration tests

- `@plan/phase-4/task-1.md` – Repository + service layers; provider-based connect/disconnect/sync/health + unit tests
- `@plan/phase-4/task-2.md` – Startup bootstrap to create exchanges/queues/bindings + integration tests

- `@plan/phase-5/task-1.md` – Cron scheduler for health checks and recovery + unit/integration tests

- `@plan/phase-6/task-1.md` – Middleware setup (logging, recovery, request ID, CORS) + unit tests
- `@plan/phase-6/task-2.md` – Controllers/routes and application services; API completion + unit/integration tests
- `@plan/phase-6/task-3.md` – API testing (smoke/E2E) + CI-friendly test script

Reference docs throughout:

- `@concepts/overview.md`
- `@architecture/architecture.md`, `@architecture/queue-provider.md`, `@architecture/middleware.md`, `@architecture/logging.md`, `@architecture/tech-stack.md`
- `@tables/README.md`
- `@apis/README.md`, `@apis/response-format.md`

## Environment Variables (centralized in `.env` and used by app + compose)

- `APP_HOST` – bind host for Gin (no hardcoding)
- `APP_PORT` – bind port for Gin (no hardcoding)
- `POSTGRES_URI` – e.g., `postgres://user:password@postgres:5432/queue_manager?sslmode=disable`
- `RABBITMQ_AMQP_URI` – e.g., `amqp://user:password@rabbitmq:5672/`
- `RABBITMQ_HTTP_URI` – e.g., `http://user:password@rabbitmq:15672/api`
- `QUEUE_PROVIDER` – `RABBITMQ`

Container versions:

- Postgres 16
- RabbitMQ 3.13-management

## Proposed Repo Structure (key files)

- `cmd/server/main.go` – app entrypoint
- `internal/config/config.go` – env parsing/validation
- `internal/server/server.go` – Gin setup and start
- `internal/db/db.go` – DB client init/ping/close
- `internal/queue/provider.go` – provider interface
- `internal/queue/rabbitmq/rabbitmq.go` – Rabbit implementation
- `internal/service/` – application services
- `internal/repository/` – repositories
- `internal/bootstrap/bootstrap.go` – startup wiring (connect, declare topology)
- `internal/cron/scheduler.go` – cron health checks/recovery
- `api/routes.go` – HTTP routes/controllers
- `Dockerfile`, `docker-compose.yml`, `.dockerignore`, `.env.example`, `Makefile`
- `pkg/testutil/` – helpers/mocks for unit/integration tests

## Testing/Tooling Conventions

- Go 1.22+, `go test ./... -count=1`
- Assertion/mocking: `github.com/stretchr/testify`
- Make targets: `make test` (unit), `make integration`, `make ci-test`
- Integration tests run against `docker compose up -d` stack

---

### Phase 1 – Project Setup (Gin + Docker)

#### task-1: Scaffold Go/Gin app with env-driven host/port + `.env.example`

- Goal: Minimal Gin server reading `APP_HOST` and `APP_PORT`; no hardcoding.
- Do:
- Initialize Go module (Go 1.22+). Add `github.com/gin-gonic/gin`, `github.com/stretchr/testify`.
- Implement `config.Load()` to read envs; fail fast if missing.
- Implement `server.Start(cfg)` binding to `APP_HOST:APP_PORT`.
- Add `/health` endpoint returning status OK.
- Create `.env.example` documenting all required envs and sample values; instruct to copy to `.env`.
- Add `Makefile` with `test`, `integration`, `run` targets.
- Unit tests:
- `internal/config`: validates missing/invalid envs and happy path.
- `internal/server`: tests router setup and `/health` handler.
- Docs: `@architecture/tech-stack.md`, `@architecture/architecture.md`.
- DoD: `go run cmd/server/main.go` starts at specified host/port; `/health` returns 200; unit tests pass `go test ./...`.
- Test: Set `.env` from `.env.example`, run locally; `curl http://$APP_HOST:$APP_PORT/health` is 200; `make test` green.

#### task-2: Add Dockerfile and .dockerignore

- Goal: Build minimal container (multi-stage) without hardcoded host/port.
- Do:
- Multi-stage build: `golang:1.22` builder → distroless/alpine runtime.
- Expose no hardcoded ports; rely on env + compose mapping.
- Use `CMD` to start binary; read env in runtime.
- Validation tests:
- Build: `docker build -t queue-manager:dev .` succeeds.
- Smoke: `docker run --rm --env-file .env -p ${APP_PORT}:${APP_PORT} queue-manager:dev` then curl `/health`.
- Docs: `@architecture/tech-stack.md`.
- DoD: Image builds; container starts and reads `APP_HOST`/`APP_PORT`; smoke passes.

#### task-3: Add docker-compose with env file support

- Goal: One-command local run; no hardcoded ports.
- Do:
- `docker-compose.yml` with `env_file: .env`.
- `ports: - "${APP_PORT}:${APP_PORT}"` and pass `APP_HOST`, `APP_PORT` to container.
- Validation tests:
- `docker compose up app` runs server; `/health` OK on host/port.
- Docs: `@architecture/architecture.md`.
- DoD: Compose brings up app; smoke test OK.

---

### Phase 2 – DB and RabbitMQ Integration

#### task-1: Postgres service + DB connect on startup

- Goal: Postgres in compose; app connects/pings DB at startup.
- Do:
- Add Postgres 16 service; volumes; healthcheck.
- Add `POSTGRES_URI` to `.env` and app config; implement `db.Connect()` with ping/close.
- Wire startup to open DB and fail if unavailable.
- Unit/Integration tests:
- Unit: `internal/db` mocks sql driver (or use testcontainers) to assert ping/close flows and error handling.
- Integration: With compose up, app logs successful DB connection; `db.Ping()` returns nil.
- Docs: `@tables/README.md`.
- DoD: App logs successful DB connection; tests pass `make test` and `make integration`.

#### task-2: RabbitMQ service + provider interface + connect on startup

- Goal: RabbitMQ in compose; provider abstraction; connect when `QUEUE_PROVIDER=RABBITMQ`.
- Do:
- Add RabbitMQ 3.13-management service; healthcheck; mgmt port 15672.
- Add `RABBITMQ_AMQP_URI`, `RABBITMQ_HTTP_URI` to `.env`.
- Define `QueueProvider` interface (connect, declare, publish, consume, ack/nack, health, close).
- Implement minimal Rabbit provider: `Connect()` only; wire selection by `QUEUE_PROVIDER`.
- Unit/Integration tests:
- Unit: provider selection logic chooses RabbitMQ; connect errors propagate; health returns expected values.
- Integration: With compose up, Rabbit connection established; mgmt UI shows connection.
- Docs: `@architecture/queue-provider.md`.
- DoD: On startup, app connects to Rabbit when provider is set; tests pass.

---

### Phase 3 – Complete RabbitMQ Provider Methods

#### task-1: Implement all RabbitMQ methods

- Goal: Fully functional provider per interface.
- Do:
- Methods: declare exchange, declare queue, bind, unbind, publish, consume, ack, nack, purge, close, health.
- Channel lifecycle and reconnect strategy primitives (basic, robust version refined in Phase 5).
- Unit/Integration tests:
- Unit: mocks or in-memory fakes to validate method contracts and error cases.
- Integration: declare/bind/publish/consume across real broker via compose.
- Docs: `@architecture/queue-provider.md`.
- DoD: All tests pass; integration shows successful publish/consume.

---

### Phase 4 – Repository + Service Layers and Startup Topology

#### task-1: Repository + service layers; provider-based ops

- Goal: Add DB repositories and application services using the provider.
- Do:
- Create repositories (stubs initially) and services to wrap provider operations.
- Implement connect, disconnect, sync, health delegating to provider.
- Unit tests:
- Repositories/services tested with mocked provider and db; verify behavior and error propagation.
- Docs: `@architecture/architecture.md`, `@tables/README.md`.
- DoD: Service tests pass; methods ready for controllers/bootstrap.

#### task-2: Startup bootstrap to create topology

- Goal: On start, declare exchanges, queues, bindings via provider.
- Do:
- `bootstrap.Run()` after connections to declare configured topology.
- Config-driven topology (YAML/env slices) to avoid hardcoding.
- Integration tests:
- With compose up, startup creates topology; mgmt UI shows expected resources.
- Docs: `@architecture/queue-provider.md`.
- DoD: Integration passes; topology visible.

---

### Phase 5 – Cron, Health Checks, Recovery

#### task-1: Cron scheduler for health and recovery

- Goal: Periodic health checks; auto-reconnect and topology sync.
- Do:
- Add `robfig/cron/v3` scheduler; schedule health checks for DB and queue.
- On unhealthy, reconnect and re-declare topology.
- Unit/Integration tests:
- Unit: cron job triggers, handler logic branches on healthy/unhealthy.
- Integration: Kill RabbitMQ; observe recovery and topology restoration.
- Docs: `@architecture/logging.md`.
- DoD: Tests pass; recovery observed.

---

### Phase 6 – API Layer, Middleware, Controllers

#### task-1: Middleware setup

- Goal: Standard middleware: logging, recovery, request ID, CORS, timeout.
- Do: Implement per `@architecture/middleware.md`; structured logs per `@architecture/logging.md`.
- Unit tests:
- Middleware behaviors (headers set, panic recovery, timeouts) using Gin test context.
- DoD: Middleware tests pass; active on routes; logs include request IDs.

#### task-2: Controllers and routes; application services

- Goal: Expose health and queue operations.
- Do:
- Routes: `/health`, `/queues`, `/exchanges`, `/bindings`, `/publish`, `/consume` (as applicable), `/sync`.
- Use standard response format per `@apis/response-format.md`.
- Unit/Integration tests:
- Unit: handlers return expected codes/payloads; error paths.
- Integration: End-to-end against compose; happy paths and error responses.
- DoD: All route tests pass with correct structure/status codes.

#### task-3: API testing

- Goal: Smoke/E2E tests.
- Do: Add simple E2E script hitting key endpoints; wire to `make ci-test`.
- DoD: Script passes locally and in container; usable in CI.

---

## Testing Matrix (per phase)

- Phase 1: Unit tests (config, server); container/compose smoke.
- Phase 2: Unit tests (db, provider select), integration (DB connect, Rabbit connect).
- Phase 3: Unit tests (provider methods), integration (declare/bind/publish/consume).
- Phase 4: Unit tests (services/repos), integration (startup topology).
- Phase 5: Unit tests (cron handlers), integration (recovery loop).
- Phase 6: Unit tests (middleware/controllers), integration (API smoke/E2E).

## Definition of Done (overall)

- All phases implemented; `.env` controls host/port and connection URIs; `.env.example` provided.
- No host/port hardcoding in code or Docker artifacts.
- `docker compose up` brings up app, Postgres 16, RabbitMQ 3.13-management.
- On startup, DB and queue connect; topology declared; health monitored; APIs pass smoke tests.
- Unit tests exist for each module; `make test` and `make integration` are green.

### To-dos

- [ ] Scaffold Go/Gin app with env-driven APP_HOST/APP_PORT
- [ ] Create multi-stage Dockerfile and .dockerignore
- [ ] Add docker-compose for app with env file and port mapping
- [ ] Add Postgres 16 service to compose with healthcheck
- [ ] Implement db.Connect/ping and wire to startup
- [ ] Add RabbitMQ 3.13-management service to compose with healthcheck
- [ ] Define QueueProvider interface and selection by QUEUE_PROVIDER
- [ ] Implement Rabbit provider Connect and startup initialization
- [ ] Implement Rabbit provider methods (declare/bind/publish/consume/etc.)
- [ ] Create repository and service layers using provider
- [ ] Add bootstrap to declare exchanges/queues/bindings on startup
- [ ] Add cron-based health checks and recovery for DB and queue
- [ ] Implement logging, recovery, request ID, CORS, timeout middleware
- [ ] Add controllers/routes using response format spec
- [ ] Add API smoke/E2E tests and docs